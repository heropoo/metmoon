---
layout: post
title: Redis加锁的几种实现
date: 2020-04-24 15:49:37
author: "Heropoo"
categories: 
    - Redis
tags:
    - Redis
    - 缓存
    - PHP
excerpt: "我们经常在工作中会碰到一些重复请求、并发等问题，而给资源加锁是一种不错的手段。我们今天就整理下使用`redis`作为分布式锁的几种实现。"
---

我们经常在工作中会碰到一些重复请求、并发等问题，而给资源加锁是一种不错的手段。我们今天就整理下使用`redis`作为分布式锁的几种实现。

`redis`可以用于几个命令是：`INCR`、`SETNX`和`SET`。

## 1. 使用`INCR`加锁
这种加锁的思路是， `key` 不存在，那么 `key` 的值会先被初始化为 0 ，然后再执行 `INCR` 操作进行加一。然后其它用户在执行 `INCR` 操作进行加一时，如果返回的数大于 `1` ，说明这个锁正在被使用当中。

```php
/***
  1、 客户端A请求服务器获取key的值为1表示获取了锁
  2、 客户端B也去请求服务器获取key的值为2表示获取锁失败
  3、 客户端A执行代码完成，删除锁
  4、 客户端B在等待一段时间后在去请求的时候获取key的值为1表示获取锁成功
  5、 客户端B执行代码完成，删除锁
**/
$res = $redis->incr($key);  // 自增1
$redis->expire($key, $ttl); // 设置锁的有效期
if($res == 1){  
    // 获取资源成功
}else{
    // 资源被其他请求占用
}
```

## 2. 使用`SETNX`加锁
这种加锁的思路是，如果 `key` 不存在，将 `key` 设置为 `value`，如果 `key` 已存在，则 `SETNX` 不做任何动作。 

```php
/***
 1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功
 2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败
 3、 客户端A执行代码完成，删除锁
 4、 客户端B在等待一段时间后在去请求设置key的值，设置成功
 5、 客户端B执行代码完成，删除锁
**/
$res = $redis->setNX($key, $value); // 当key不存在时设置key=value
$redis->expire($key, $ttl); // 设置锁的有效期
if($res){  
    // 获取资源成功
}else{
    // 资源被其他请求占用
}
```

上面两种方法都有一个问题，会发现，都需要设置 `key` 过期时间。那么为什么要设置`key`过期时间呢？如果请求执行因为某些原因意外退出了，导致创建了锁但是没有删除锁，那么这个锁将一直存在（redis不设置key的过期时间，默认是永久的），以至于一直处于加锁状态。于是乎我们需要给锁加一个过期时间以防不测。

但是借助 `Expire` 来设置就不是原子性操作了。所以还可以通过`redis`事务来确保原子性。那上面的代码就要优化成：
```php
// 第一种方式的加锁
$redis->multi();    // 标记一个事务块的开始
$res = $redis->incr($key);  
$redis->expire($key, $ttl);
$redis->exec();   // 提交事务
if($res == 1){  
    // 获取资源成功
}else{
    // 资源被其他请求占用
}

// 第二种方式的加锁
$redis->multi();    // 标记一个事务块的开始
$res = $redis->setNX($key, $value); 
$redis->expire($key, $ttl); 
$redis->exec();   // 提交事务
if($res){  
    // 获取资源成功
}else{
    // 资源被其他请求占用
}
```

上面代码看起来是不是很繁琐。好在`redis`官方从版本 2.6.12 开始 `SET` 命令本身已经包含了设置过期时间的功能。

## 3. 使用`SET`加锁
```php
/*** 
 1、 客户端A请求服务器设置key的值，如果设置成功就表示加锁成功
 2、 客户端B也去请求服务器设置key的值，如果返回失败，那么就代表加锁失败
 3、 客户端A执行代码完成，删除锁
 4、 客户端B在等待一段时间后在去请求设置key的值，设置成功
 5、 客户端B执行代码完成，删除锁
**/    

$res = $redis->set($key, $value, ['nx', 'ex' => $ttl]);  //nx代表当key不存在时设置 ex代表设置过期时间
if($res){  
    // 获取资源成功
}else{
    // 资源被其他请求占用
}
```

## 4. 其他问题
虽然上面一步已经满足了我们的需求，但是还是要考虑其它问题？
- 1、 redis发现锁失败了要怎么办？中断请求还是循环请求？
- 2、 循环请求的话，如果有一个获取了锁，其它的在去获取锁的时候，是不是容易发生抢锁的可能？
- 3、 锁提前过期后，客户端A还没执行完，然后客户端B获取到了锁，这时候客户端A执行完了，会不会在删锁的时候把B的锁给删掉？

## 5. 解决办法
- 针对问题1：使用循环请求，循环请求去获取锁
- 针对问题2：针对第二个问题，在循环请求获取锁的时候，加入睡眠功能，等待几毫秒在执行循环
- 针对问题3：在加锁的时候存入的key是随机的。这样的话，每次在删除key的时候判断下存入的key里的value和自己存的是否一样
```php
do {  //针对问题1，使用循环
    $timeout = 10;
    $roomid = 10001;
    $key = 'room_lock';
    $value = 'room_'.$roomid;  //分配一个随机的值针对问题3
    $isLock = $redis->set($key, $value, 'ex', $timeout, 'nx');//ex 秒
    if ($isLock) {
        if ($redis->get($key) == $value) {  //防止提前过期，误删其它请求创建的锁
            //执行内部代码
            $redos->del($key);
            continue;//执行成功删除key并跳出循环
        }
    } else {
        usleep(5000); //睡眠，降低抢锁频率，缓解redis压力，针对问题2
    }
} while(!$isLock);
```

## 参考：
- http://ukagaka.github.io/php/2017/09/21/redisLock.html

